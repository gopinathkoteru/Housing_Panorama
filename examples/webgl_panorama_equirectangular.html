<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - equirectangular panorama demo</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background-color: #000000;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px; width: 100%;
			color: #ffffff;
			padding: 5px;
			font-family:Monospace;
			font-size:13px;
			font-weight: bold;
			text-align:center;
		}

		a {
			color: #ffffff;
		}
	</style>
</head>
<body>

	<div id="container"></div>
	<div id="info">
		<a href="http://threejs.org" target="_blank">three.js webgl</a> - equirectangular panorama demo. photo by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank">JÃ³n Ragnarsson</a>.<br />
		drag equirectangular texture into the page.
	</div>

	<script src="../build/three.min.js"></script>

	<script>

		var camera, scene, renderer;
		var raycaster;
		raycaster = new THREE.Raycaster();
		var current_pano;
		var clear_pano;
		var curr_speed,acc,time;
		var test,remove;
		var cam_pos;

		var isUserInteracting = false,
		onMouseDownMouseX = 0, onMouseDownMouseY = 0,
		lon = 0, onMouseDownLon = 0,
		lat = 0, onMouseDownLat = 0,
		phi = 0, theta = 0;

		var hotspots_angle = [[[1,109,47]], [[2,52,48], [4,111,98], [5,122,51], [0,303,43]], [[3,107,58], [1,230,48]], [[2,293,58], [4,185,41]], [[3,5,41], [1,288,93], [5,278,45]], [[1,307,51], [4,105,46]]]; 

		init('panos/1/resized_1.jpg');
		animate();

		function loadNewmesh(pano_id, path,old_pano,dist,angle)
		{
			var geometry = new THREE.SphereGeometry( 500, 60, 40 );
			geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

			var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( path )} );

			mesh = new THREE.Mesh( geometry, material );
			mesh.name = "current_mesh";
			mesh.material.transparent = true;
			mesh.material.opacity = 1.0;	

			var new_pano = mesh;
			scene.add( mesh );
			curr_speed = 6;
			time = 10;
			dist = 5*dist;
			test = false;
			remove = false;

			acc = (2*(curr_speed*time - dist))/(time*time);
			loadclearmesh(pano_id);
			updateOpacity(old_pano,new_pano,dist,angle,pano_id,1);


		}
		function loadclearmesh(pano_id)
		{
			pano_id += 1;
			var path = "panos/" + pano_id +"/resized_"+pano_id+ ".jpg";
			var geometry = new THREE.SphereGeometry( 500, 60, 40 );
			geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

			var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( path )} );

			mesh = new THREE.Mesh( geometry, material );
			mesh.name = "current_mesh";
			mesh.material.transparent = true;
			mesh.material.opacity = 0;
			scene.add( mesh );
			clear_pano = mesh;

			return;

		}
		function updateclarity(new_pano,clear_pano)
		{
			new_pano.material.opacity -= 0.01;
			clear_pano.material.opacity += 0.3;
			if(clear_pano.material.opacity>=1)
			{
				clear_pano.material.opacity =1;
				return;
			}
			setTimeout(function(){updateclarity(new_pano,clear_pano);}, 50);
		}
		function updateOpacity(old_pano,new_pano,dist,angle,pano_id,count)
		{ 
			if(remove==false)
			{
				var speed;
				speed = -1*curr_speed*count + 0.5*acc*count*count;

				old_pano.position.x = speed*Math.cos(THREE.Math.degToRad(angle ));
				old_pano.position.z = speed*Math.sin(THREE.Math.degToRad(angle ));

				count = count + 1;
				old_pano.material.opacity -= 0.01;
			}
			if(remove==true)
			{
				count = count + 1;
				clear_pano.material.opacity += 0.1;
				new_pano.material.opacity -= 0.03;
			}
			if(count==time && remove==false)
			{
				scene.remove(old_pano);
				count = 0;

				remove = true;

			}
			if(count==time && remove==true)
			{
				new_pano.material.opacity = 1;
				scene.remove(new_pano);
				Hotspots(pano_id);
				return;
			}

			setTimeout(function(){updateOpacity(old_pano,new_pano,dist,angle,pano_id,count);}, 50); 
		}	
		function removemesh(pano_id,dist,angle) {
			current_pano = pano_id;
			var old_pano = scene.getObjectByName("current_mesh");

			var len = scene.children.length;
			var p=0;
			for ( i = 0; i < len; i ++ ) {
				var object = scene.children[ p];

				if(object.name!=old_pano.name)
				{
					scene.remove(object);
				}
				else
				{
					p = p + 1;
				}
			}
			var images_loc = pano_id+1;
			images_loc = "panos/" + images_loc +"/blur_"+images_loc+ ".jpg";
			loadNewmesh(pano_id, images_loc,old_pano,dist,angle);
			animate();
		}

		function init(path) 
		{
			var container, mesh;

			container = document.getElementById( 'container' );

			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
			camera.target = new THREE.Vector3( 0, 0, 0 );

			scene = new THREE.Scene();

			var geometry = new THREE.SphereGeometry( 500, 60, 40 );
			geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

			var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( path )} );

			mesh = new THREE.Mesh( geometry, material );
			mesh.name="current_mesh";
			current_pano = 0;
			mesh.material.transparent = true;

			scene.add( mesh );
			Hotspots(0);

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
			document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false);

			document.addEventListener( 'keydown', onDocumentKeyDown, false );
			document.addEventListener( 'keyup', onDocumentKeyUp, false );

			document.addEventListener( 'dragover', function ( event ) {

				event.preventDefault();
				event.dataTransfer.dropEffect = 'copy';

			}, false );

			document.addEventListener( 'dragenter', function ( event ) {

				document.body.style.opacity = 0.5;

			}, false );

			document.addEventListener( 'dragleave', function ( event ) {

				document.body.style.opacity = 1;

			}, false );

			document.addEventListener( 'drop', function ( event ) {

				event.preventDefault();

				var reader = new FileReader();
				reader.addEventListener( 'load', function ( event ) {

					material.map.image.src = event.target.result;
					material.map.needsUpdate = true;

				}, false );
				reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

				document.body.style.opacity = 1;

			}, false );


			window.addEventListener( 'resize', onWindowResize, false );

		}

		function Hotspots(pano_id)
		{
			total = hotspots_angle[pano_id].length;
			for(i=0;i<total;i++)
			{
				add_Hotspot(hotspots_angle[pano_id][i][0],hotspots_angle[pano_id][i][1],hotspots_angle[pano_id][i][2]);
			}
		}
		function add_Hotspot(pano_id,angle,dist)
		{
			var geometry = new THREE.BoxGeometry( 2,2,2,1,1,1);
			var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
			var cube = new THREE.Mesh( geometry, material );

			rad_angle = THREE.Math.degToRad( angle );
			cube.position.x = dist*Math.cos(rad_angle);
			cube.position.y = -10;
			cube.position.z = dist*Math.sin(rad_angle);
			cube.pano_id = pano_id;
			cube.dist = dist;
			cube.angle = angle;
			cube.name = "current_hotspot";
			scene.add( cube );

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}
		function move_camera(angle,mesh)
		{
			if(cam_pos*angle<=0)
			{
				removemesh(mesh.pano_id,mesh.dist,mesh.angle);
				scene.remove(mesh);
				return;
			}
			lon = lon + cam_pos*2;
			angle = angle - cam_pos*2;

			setTimeout(function(){move_camera(angle,mesh);}, 5); 
		}

		function onDocumentMouseDown( event ) {

			event.preventDefault();

			isUserInteracting = true;

			onPointerDownPointerX = event.clientX;
			onPointerDownPointerY = event.clientY;

			onPointerDownLon = lon;
			onPointerDownLat = lat;


			var vector = new THREE.Vector3();
			vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
			vector.unproject( camera );
			raycaster.set( camera.position, vector.sub( camera.position ).normalize() );


			var intersects = raycaster.intersectObjects( scene.children, true );

			if ( intersects.length > 0  && intersects[0].object.name=="current_hotspot") {

				var angle = intersects[0].object.angle - lon;
				if(angle > 0)
				{
					cam_pos = 1;
				}
				else
				{
					cam_pos = -1;
				}
				move_camera(angle,intersects[0].object);


			}

		}

		function onDocumentMouseMove( event ) {

			if ( isUserInteracting === true ) {

				lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
				lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

			}

		}

		function onDocumentMouseUp( event ) {

			isUserInteracting = false;

		}

		var maxspeed = 5;
		var current_speed = 0.4;
		var done = false;
		function onDocumentKeyDown( event ) {

			if (!event)
				event = window.event;
			var code = event.keyCode;

			if (code == 37)
				lon-=current_speed;
			else if ( code ==39 )
				lon += current_speed;
			else if (code == 38)
			{
				if(done == false)
				{
					var total = hotspots_angle[current_pano].length;
					var near_angle,near_id;
					var flag = false;
					var temp;

					for(i=0;i<total;i++)
					{
						temp = hotspots_angle[current_pano][i][1];
						if(temp < 0 )
						{
							temp = temp + 360;
						}
						console.log(temp + " " + lon);
						if( ((lon>=45) &&(lon<=315) && (temp<=(lon+45)%360) &&(temp>=(lon-45)%360)) || ((lon<=45) && (temp>=0) && (temp<=lon+45)) || ((lon<=45)&&(temp>=(lon-45)%360) && (temp<=360)) ||  ((lon>=315) && (temp>=(lon-45)) && (temp<=360)) || ((lon>=315)&&(temp>=0) &&(temp<= (lon+45)%360)) )
						{

							if(flag == false)
							{
								near_angle = temp;
								near_id = i;

								flag = true;
							}
							if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
							{
								near_angle = temp;
								near_id = i;

								flag = true;

							}
						}
					}
					if(flag == true)
					{
						removemesh(hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
					}
					done = true;
				}
			}
			else if ( code == 40 )
			{
				if(done == false)
				{
					var total = hotspots_angle[current_pano].length;
					var near_angle,near_id;
					var flag = false;
					var temp;
					lon = lon % 360;
					for(i=0;i<total;i++)
					{
						lon = lon % 360;
						temp = hotspots_angle[current_pano][i][1] - 90;
						if(temp < 0 )
						{
							temp = temp + 360;
						}

						if((temp>=(lon+135)%360) && (temp<=(lon+225)%360))
						{

							if(flag==false)
							{
								near_angle = temp;
								near_id = i;

								flag = true;
							}
							if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
							{
								near_angle = temp;
								near_id = i;

								flag = true;

							}
						}
					}
					if(flag == true)
					{
						removemesh(hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
					}
					done = true;
				}
			}
			if (isUserInteracting == true) {
				if(current_speed < maxspeed)
					current_speed+=0.1;
			}
			isUserInteracting = true;
		}


		function onDocumentKeyUp ( event ) 
		{

			isUserInteracting = false;
			current_speed = 0.4;
			done = false;
		}

		function onDocumentMouseWheel( event ) {



			if ( event.wheelDeltaY ) {

				camera.fov -= event.wheelDeltaY * 0.05;



			} else if ( event.wheelDelta ) {

				camera.fov -= event.wheelDelta * 0.05;



			} else if ( event.detail ) {

				camera.fov += event.detail * 1.0;

			}

			camera.updateProjectionMatrix();

		}

		function animate() {

			requestAnimationFrame( animate );
			update();

		}

		function update() {

			if(lon > 360)
			{
				lon -= 360;
			}
			else if (lon < 0)
			{
				lon += 360;
			}
			lat = Math.max( - 85, Math.min( 85, lat ) );
			phi = THREE.Math.degToRad( 90 - lat );
			theta = THREE.Math.degToRad( lon );

			camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
			camera.target.y = 500 * Math.cos( phi );
			camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );

			camera.lookAt( camera.target );

			renderer.render( scene, camera );

		}

	</script>
</body>
</html>
