
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - equirectangular panorama demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				font-weight: bold;
				text-align:center;
			}

			a {
				color: #ffffff;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js webgl</a> - equirectangular panorama demo. photo by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank">JÃ³n Ragnarsson</a>.<br />
			drag equirectangular texture into the page.
		</div>

		<script src="../build/three.min.js"></script>

		<script>

			var camera, scene, renderer, raycaster;
			raycaster = new THREE.Raycaster();
			var mouse;
			var cam_angle=0;
			var test;
			var current_pano; //for up and down arrow key functionality
			mouse = new THREE.Vector2();
			var curr_speed,acc,time;

			var texture_placeholder,
			isUserInteracting = false,
			onMouseDownMouseX = 0, onMouseDownMouseY = 0,
			lon = 90, onMouseDownLon = 0,
			lat = 0, onMouseDownLat = 0,
			phi = 0, theta = 0,

			target = new THREE.Vector3();
			var hotspots_angle = [[[1,109,47]], [[2,52,48], [4,111,98], [5,122,51], [0,303,43]], [[3,107,58], [1,230,48]], [[2,293,58], [4,185,41]], [[3,5,41], [1,288,93], [5,278,45]], [[1,307,51], [4,105,46]]]; 

			init('panos/1.tiles/resized_1.jpg');
			animate();



			function loadNewmesh(pano_id, new_img ,old_pano,dist,angle)
			{
				var geometry = new THREE.SphereGeometry( 500, 60, 40 );
				geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

				var material = new THREE.MeshBasicMaterial( {
					map: THREE.ImageUtils.loadTexture( new_img )
				} );

				mesh = new THREE.Mesh( geometry, material );
				var new_pano = mesh;
				mesh.name = "current_mesh";
				mesh.material.opacity = 0;
				
				scene.add( mesh );

				curr_speed = 5;
				time = 10;
				dist = 2*dist;
				
				acc = (2*(curr_speed*time - dist))/(time*time);
				//console.log(old_pano);
				updateOpacity(old_pano,new_pano,dist,angle,pano_id,1);
				
				
			}


			function updateOpacity(old_pano,new_pano,dist,angle,pano_id,count) { 
				var speed = -1*curr_speed*count + 0.5*acc*count*count;
				old_pano.position.x = speed*Math.cos(THREE.Math.degToRad(angle ));
				old_pano.position.z = speed*Math.sin(THREE.Math.degToRad(angle ));

				old_pano.material.opacity -= 0.1;
				new_pano.material.opacity += 0.2;
  					if(count==time ) {
   						scene.remove(old_pano);
   						//	scene.add(new_pano)
						new_pano.material.opacity = 1;
   						Hotspots(pano_id);
   						return;
 					}
 					else {
 						setTimeout(function(){updateOpacity(old_pano,new_pano,dist,angle,pano_id,count+1);}, 50); // 50 is the delay, 50milliseconds
 					}
			}


			function removemesh(pano_id,dist,angle) {
					current_pano = pano_id;
    				var old_pano = scene.getObjectByName("current_mesh");
    				var len = scene.children.length;
    				var p=0;
    				for ( i = 0; i < len; i ++ ) {
    					var object = scene.children[ p];
    					if(object.name!=old_pano.name) {
        					scene.remove(object);
        				}
        				else {
        					p = p + 1;
        				}
					}
    				var images_loc = pano_id+1;
					loadNewmesh(pano_id, "panos/" + images_loc + ".tiles/resized_" + images_loc + ".jpg" ,old_pano,dist,angle);
    				animate();
			}


			function init(img) {

				var container, mesh;

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
				camera.target = new THREE.Vector3( 0, 0, 0 );

				scene = new THREE.Scene();

				var geometry = new THREE.SphereGeometry( 500, 60, 40 );
				geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

				var material = new THREE.MeshBasicMaterial( {
					map: THREE.ImageUtils.loadTexture( img )
				} );



				mesh = new THREE.Mesh( geometry, material );
				mesh.name = "current_mesh";
				current_pano = 0;
				console.log(mesh);
				
				scene.add( mesh );

				test = mesh;
				Hotspots(0);

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
				document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false);

				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );


				document.addEventListener( 'dragover', function ( event ) {

					event.preventDefault();
					event.dataTransfer.dropEffect = 'copy';

				}, false );

				document.addEventListener( 'dragenter', function ( event ) {

					document.body.style.opacity = 0.5;

				}, false );

				document.addEventListener( 'dragleave', function ( event ) {

					document.body.style.opacity = 1;

				}, false );

				document.addEventListener( 'drop', function ( event ) {

					event.preventDefault();

					var reader = new FileReader();
					reader.addEventListener( 'load', function ( event ) {

						material.map.image.src = event.target.result;
						material.map.needsUpdate = true;

					}, false );
					reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

					document.body.style.opacity = 1;

				}, false );

				window.addEventListener( 'resize', onWindowResize, false );

			}


			function Hotspots(pano_id) {
                
                total = hotspots_angle[pano_id].length;
                for(i=0;i<total;i++) {
                    add_Hotspot(hotspots_angle[pano_id][i][0],hotspots_angle[pano_id][i][1],hotspots_angle[pano_id][i][2]);
                }
            }


            function add_Hotspot(pano_id,angle,dist) {

                var geometry = new THREE.BoxGeometry( 2,2,2,1,1,1);
                var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
                var cube = new THREE.Mesh( geometry, material );

                rad_angle = THREE.Math.degToRad( angle );
                cube.position.x = dist*Math.cos(rad_angle);
                cube.position.y = -10;
                cube.position.z = dist*Math.sin(rad_angle);
				cube.pano_id = pano_id;
				cube.dist = dist;
				cube.angle = angle;
				cube.name = "current_hotspot";
                scene.add( cube );

            }


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			
			function onDocumentMouseDown( event ) {

				event.preventDefault();

				isUserInteracting = true;

				onPointerDownPointerX = event.clientX;
				onPointerDownPointerY = event.clientY;

				onPointerDownLon = lon;
				onPointerDownLat = lat;
				mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
                                mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

				var vector = new THREE.Vector3();
                vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 ); // z = 0.5 important!
    			vector.unproject( camera );
    			raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
				
				
				var intersects = raycaster.intersectObjects( scene.children, true );
				console.log(intersects + " " + intersects.length);
				
				if ( intersects.length > 0 && intersects[0].object.name=="current_hotspot" ) {
				  // console.log(intersects[0].object.dist);
				//  console.log(intersects[0].object.angle);
     				removemesh(intersects[0].object.pano_id,intersects[0].object.dist,intersects[0].object.angle);
     				scene.remove(intersects[0].object);

    			}

			}


			function onDocumentMouseMove( event ) {

				if ( isUserInteracting === true ) {

					lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

				}

			}

			
			function onDocumentMouseUp( event ) {

				isUserInteracting = false;

			}

			
			function onDocumentMouseWheel( event ) {

				// WebKit

				if ( event.wheelDeltaY ) {

					camera.fov -= event.wheelDeltaY * 0.05;

				// Opera / Explorer 9

				} else if ( event.wheelDelta ) {

					camera.fov -= event.wheelDelta * 0.05;

				// Firefox

				} else if ( event.detail ) {

					camera.fov += event.detail * 1.0;

				}

				camera.updateProjectionMatrix();

			}


			var maxspeed = 5;
			var current_speed = 0.4;
			var done = false;
			function onDocumentKeyDown( event ) {

				if (!event)
          			event = window.event;
     			var code = event.keyCode;
     			//console.log(event);
     			
     			if (code == 37)
     				lon-=current_speed;
     			else if ( code ==39 )
     				lon += current_speed;
     			else if (code == 38)
     			{
     				if(done == false)
     				{
     					var total = hotspots_angle[current_pano].length;
     					var near_angle,near_id;
     					var flag = false;
     					var temp;
     					 
     					for(i=0;i<total;i++)
                        {
                         	temp = hotspots_angle[current_pano][i][1];
                         	if(temp < 0 )
                         	{
                         		temp = temp + 360;
                         	}
                         	console.log(temp + " " + lon);
                            if( ((lon>=45) &&(lon<=315) && (temp<=(lon+45)%360) &&(temp>=(lon-45)%360)) || ((lon<=45) && (temp>=0) && (temp<=lon+45)) || ((lon<=45)&&(temp>=(lon-45)%360) && (temp<=360)) ||  ((lon>=315) && (temp>=(lon-45)) && (temp<=360)) || ((lon>=315)&&(temp>=0) &&(temp<= (lon+45)%360)) )
                            {

                            	if(flag == false)
                            	{
                            			near_angle = temp;
                            			near_id = i;
                            			
                            			flag = true;
                            	}
                            	if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
                            	{
                            			near_angle = temp;
                            			near_id = i;
                            			
                            			flag = true;

                            	}
                            }
                        }
                        if(flag == true)
                        {
                        	removemesh(hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
     					}
     					done = true;
     				}
     				//up;
     			}
     			else if ( code == 40 )
     			{
     				if(done == false)
     				{
     					var total = hotspots_angle[current_pano].length;
     					var near_angle,near_id;
     					var flag = false;
     					var temp;
     					lon = lon % 360;
     					for(i=0;i<total;i++)
                        {
                         	lon = lon % 360;
                         	temp = hotspots_angle[current_pano][i][1];
                         	if(temp < 0 )
                         	{
                         		temp = temp + 360;
                         	}
                         	
                            if((temp>=(lon+135)%360) && (temp<=(lon+225)%360))
                            {

                            	if(flag==false)
                            	{
                            			near_angle = temp;
                            			near_id = i;
                            			
                            			flag = true;
                            	}
                            	if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
                            	{
                            			near_angle = temp;
                            			near_id = i;
                            			
                            			flag = true;

                            	}
                            }
                        }
                        if(flag == true)
                        {
                        	removemesh(hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
     					}
     					done = true;
     				}
     				//down
     			}
     			if (isUserInteracting == true) {
     				if(current_speed < maxspeed)
     					current_speed+=0.1;
     			}
     			isUserInteracting = true;
     			
			}


			function onDocumentKeyUp ( event ) {

				isUserInteracting = false;
				current_speed = 0.4;
				done = false;
			}


			function animate() {

				requestAnimationFrame( animate );
				update();

			}

			function update() {

			//	if ( isUserInteracting === false ) {

			//		lon += 0.1;

			//	}
				if(lon > 360)
				{
					lon -= 360;
				}
				else if (lon < 0)
				{
					lon += 360;
				}
				lat = Math.max( - 85, Math.min( 85, lat ) );
				phi = THREE.Math.degToRad( 90 - lat );
				theta = THREE.Math.degToRad( lon );

				camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
				camera.target.y = 500 * Math.cos( phi );
				camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );

				camera.lookAt( camera.target );

				/*
				// distortion
				camera.position.copy( camera.target ).negate();
				*/

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
