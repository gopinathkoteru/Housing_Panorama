<!DOCTYPE html>
<html lang="en">
<head>
	<title>Housing Panorama</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		background-color: #000000;
		margin: 0px;
		overflow: hidden;
		opacity: : 0;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		color: #ffffff;
		padding: 5px;
		font-family:Monospace;
		font-size:13px;
		font-weight: bold;
		text-align:center;
	}

	a {
		color: #ffffff;
	}
	</style>
</head>
<body>

	<div id="container"></div>

	<script src="../build/three.min.js"></script>

	<script>
	var camera, scene, renderer;
	var raycaster;
	var mesh1,mesh2,mesh3;
	raycaster = new THREE.Raycaster();
	var current_pano;
	var clear_pano,old_pano,new_pano;
	var curr_speed,acc,time;
	var test,remove;
	var cam_pos;
	var time_out;
	var isUserInteracting = false,
	onMouseDownMouseX = 0, onMouseDownMouseY = 0,
	lon = 0, onMouseDownLon = 0,
	lat = 0, onMouseDownLat = 0,
	phi = 0, theta = 0;

	var hotspots_angle = [[[1,109,47]], [[2,52,48], [4,111,98], [0,303,43]], [[3,107,58], [1,230,48]], [[2,293,58], [4,185,45]], [[3,5,41], [1,288,93]]]; 
	var mouse_speed = 0.3;
	init();
	animate();

	function loadNewmesh(pano_id,dist,angle)
	{
		var par = pano_id + 1;
		var path = "panos/blur_"+par+"/blur_";
		
		//mesh2.visible = true;
		mesh2.material.materials[0].map = gettexture(path + "r.jpg");
		mesh2.material.materials[1].map = gettexture(path + "l.jpg");
		mesh2.material.materials[2].map = gettexture(path + "u.jpg");
		mesh2.material.materials[3].map = gettexture(path + "d.jpg");
		mesh2.material.materials[4].map = gettexture(path + "f.jpg");
		mesh2.material.materials[5].map = gettexture(path + "b.jpg");

		for(i=0;i<6;i++)
		{
			mesh2.material.materials[i].opacity = 0;
			//mesh1.material.materials[i].opacity = 0;
		}
		
		//new_pano = create_mesh(path,0);
		
		//new_pano = mesh2;
		//scene.add( mesh );
		curr_speed = 3;
		time = 30;
		dist = dist+30;
		test = false;
		remove = false;

		acc = (2*(curr_speed*time - dist))/(time*time);
		loadclearmesh(pano_id);
		//location.reload();
		updateOpacity(dist,angle,pano_id,1);
	}
	
	function loadclearmesh(pano_id)
	{
		pano_id += 1;
		
		var path = "panos/"+pano_id+"/mobile_";

		//mesh3.visible = true;
		mesh3.material.materials[0].map = gettexture(path+"r.jpg");
		mesh3.material.materials[1].map = gettexture(path+"l.jpg");
		mesh3.material.materials[2].map = gettexture(path+"u.jpg");
		mesh3.material.materials[3].map = gettexture(path+"d.jpg");
		mesh3.material.materials[4].map = gettexture(path+"f.jpg");
		mesh3.material.materials[5].map = gettexture(path+"b.jpg");

		for(i=0;i<6;i++)
		{
			mesh3.material.materials[i].opacity = 0;
		}
		
		//clear_pano = create_mesh(path,0);
		//clear_pano = mesh3;

		return;

	}

	function updateOpacity(dist,angle,pano_id,count)
	{ 
		//console.log(camera.fov);
		if(remove==false)
		{
			//var speed;
			//speed = -1*curr_speed*count + 0.5*acc*count*count;
			//dist = 100;

			camera.fov -= dist*0.01;
			camera.updateProjectionMatrix();	
			
			//old_pano.position.x = speed*Math.cos(THREE.Math.degToRad(angle ));
			//old_pano.position.z = speed*Math.sin(THREE.Math.degToRad(angle ));

			mesh2.position.x = dist*Math.cos(THREE.Math.degToRad(angle ));
			mesh2.position.z = dist*Math.sin(THREE.Math.degToRad(angle ));


			//mesh1.position.x = speed*Math.cos(THREE.Math.degToRad(angle ));
			//mesh1.position.z = speed*Math.sin(THREE.Math.degToRad(angle ));
			count = count + 1;
			for(i=0;i<6;i++)
			{
				//old_pano.material.materials[i].opacity -= 1/time;
				//new_pano.material.materials[i].opacity += 1/time;
				mesh1.material.materials[i].opacity -= 1/time;
				mesh2.material.materials[i].opacity += 1/time;
			}
		}
		if(remove==true)
		{
			//camera.fov += dist*0.01;
			//camera.updateProjectionMatrix();


			//mesh2.position.x =dist*Math.cos(THREE.Math.degToRad(angle ));
			//mesh2.position.z =dist*Math.sin(THREE.Math.degToRad(angle ));	
			
			count = count + 1;
			for(i=0;i<6;i++)
			{
				mesh2.material.materials[i].opacity -= 1/time;
				mesh3.material.materials[i].opacity += 1/time;
				//new_pano.material.materials[i].opacity -= 1/time;
			}
		}
		if(count==time && remove==false)
		{	
		//	old_pano.geometry.dispose();
			for(i=0;i<6;i++)
			{
				mesh1.material.materials[i].map.dispose();
				//delete mesh1.material.materials[i].map;
				//mesh1.material.materials[i].map = undefined;
				//old_pano.material.materials[i].dispose();	
			}
			mesh2.position.x = 0;
			mesh2.position.z = 0;
			camera.fov = 75;
			camera.updateProjectionMatrix();


			count = 0;
			for(i=0;i<6;i++)
			{
				mesh2.material.materials[i].opacity = 1;
			}
			remove = true;
			mesh1.position.x = 0;
			mesh1.position.z = 0;
			//scene.remove(old_pano);
		}
		if(count==time && remove==true)
		{
			
			//new_pano.geometry.dispose();
			for(i=0;i<6;i++)
			{
				mesh2.material.materials[i].map.dispose();
				//delete mesh2.material.materials[i].map;
				//mesh2.material.materials[i].map = undefined;
				//new_pano.material.materials[i].dispose();	
			}
		//	scene.remove(new_pano);
			for(i=0;i<6;i++)
			{
				//console.log(mesh3.material.materials[i].map.image.src);
				mesh1.material.materials[i].map = gettexture(mesh3.material.materials[i].map.image.src);
				console.log(mesh1.material.materials[i].map);
				mesh1.material.materials[i].opacity = 1;
				mesh3.material.materials[i].opacity = 0;

				//mesh3.material.materials[i].map = undefined;
			}
			for(i=0;i<6;i++)
			{
				mesh3.material.materials[i].map.dispose();
				//delete mesh3.material.materials[i].map;
			}
			console.log(scene);
			/*for(i=0;i<6;i++)
			{
				mesh3.material.materials[i].map = 0;
			}*/
			console.log(mesh1);
			mouse_speed += 0.02;
			Hotspots(pano_id);
			clearTimeout(time_out);
			
			return;
		}
		var function_name = function(){updateOpacity(dist,angle,pano_id,count);}
		clearTimeout(time_out);
		time_out = setTimeout(function_name, 60); 
	}	
	function removemesh(pano_id,dist,angle) {
		current_pano = pano_id;
		old_pano = scene.getObjectByName("current_mesh");

		var len = scene.children.length;
		var p=0;
		for ( i = 0; i < len; i ++ ) {
			var object = scene.children[ p];

			if(object.name!=old_pano.name)
			{
				
				object.geometry.dispose();
				object.material.dispose();
				scene.remove(object);
			}
			else
			{
				p = p + 1;
			}
		}
		loadNewmesh(pano_id,dist,angle);
		animate();
	}
	
	function create_mesh(path,opacity)
	{
		var materials = [

					loadTexture(path+"r.jpg"), // right
					loadTexture(path+"l.jpg"), // left
					loadTexture(path+"u.jpg"), // top
					loadTexture(path+"d.jpg"), // bottom
					loadTexture(path+"f.jpg"), // front
					loadTexture(path+"b.jpg")  // back

				];
		var mesh = new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 300, 7, 7, 7 ), new THREE.MeshFaceMaterial( materials ) );
		mesh.scale.x = -1;

		for(i=0;i<6;i++)
		{
			mesh.material.materials[i].transparent = true;
			mesh.material.materials[i].opacity = opacity;
			mesh.material.materials[i].blending = THREE.AdditiveBlending;
		}
		mesh.name = "current_mesh";
		scene.add(mesh);

		return mesh;

	}

	function loadTexture( path ) {

				var texture = new THREE.Texture( texture_placeholder );
				var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );

				var image = new Image();
				image.onload = function () {

					texture.image = this;
					texture.needsUpdate = true;

				};
				image.src = path;

				return material;

	}

	function gettexture(path)
	{
		var texture = new THREE.Texture( texture_placeholder );

				var image = new Image();
				image.onload = function () {

					texture.image = this;
					texture.needsUpdate = true;

				};
				image.src = path;

				return texture;
	}

	function init(path) 
	{
		var container, mesh;

		container = document.getElementById( 'container' );

		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
		camera.target = new THREE.Vector3( 0, 0, 0 );
		//console.log(camera);

		scene = new THREE.Scene();

		texture_placeholder = document.createElement( 'canvas' );
		texture_placeholder.width = 128;
		texture_placeholder.height = 128;

		var path = "panos/1/mobile_";
		mesh1 = create_mesh(path,1.0);
		//mesh1.material.materials[0].map.needsUpdate = true;
		//mesh1.material.materials[0].map.image.src = "panos/2/mobile_b.jpg";
		mesh2 = create_mesh(path,0.0);
		mesh3 = create_mesh(path,0.0);

		current_pano = 0;
		Hotspots(0);

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mouseup', onDocumentMouseUp, false );
		document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
		document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false);

		document.addEventListener( 'keydown', onDocumentKeyDown, false );
		document.addEventListener( 'keyup', onDocumentKeyUp, false );

		document.addEventListener( 'dragover', function ( event ) {

			event.preventDefault();
			event.dataTransfer.dropEffect = 'copy';

		}, false );

		document.addEventListener( 'dragenter', function ( event ) {

			document.body.style.opacity = 0.5;

		}, false );

		document.addEventListener( 'dragleave', function ( event ) {

			document.body.style.opacity = 1;

		}, false );

		document.addEventListener( 'drop', function ( event ) {

			event.preventDefault();

			var reader = new FileReader();
			reader.addEventListener( 'load', function ( event ) {

				material.map.image.src = event.target.result;
				material.map.needsUpdate = true;

			}, false );
			reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

			document.body.style.opacity = 1;

		}, false );


		window.addEventListener( 'resize', onWindowResize, false );

	}
	
	function Hotspots(pano_id)
	{
		var total = hotspots_angle[pano_id].length;
		for(i=0;i<total;i++)
		{
			add_Hotspot(hotspots_angle[pano_id][i][0],hotspots_angle[pano_id][i][1],hotspots_angle[pano_id][i][2]);
		}
	}

	function add_Hotspot(pano_id,angle,dist)
	{
		var geometry = new THREE.BoxGeometry( 2,2,2,1,1,1);
		var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
		var cube = new THREE.Mesh( geometry, material );

		angle = angle - 90;
		rad_angle = THREE.Math.degToRad( angle );
		cube.position.x = dist*Math.cos(rad_angle);
		cube.position.y = -10;
		cube.position.z = dist*Math.sin(rad_angle);
		cube.pano_id = pano_id;
		cube.dist = dist;
		cube.angle = angle;
		cube.name = "current_hotspot";
		scene.add( cube );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}
	function move_camera_lat (pano_id,dist,hotspot_angle) {
		
		lat = lat - cam_pos*2;
		if(Math.abs(lat) <  2)
		{
			clearTimeout(time_out);
			removemesh(pano_id,dist,hotspot_angle);
			return;
		}
		var function_name = function(){move_camera_lat(pano_id,dist,hotspot_angle);}
		clearTimeout(time_out);
		time_out = setTimeout(function_name, 50); 
	}
	function move_camera(angle,pano_id,dist,hotspot_angle)
	{
		if(cam_pos*angle<=0)
		{
			clearTimeout(time_out);
			cam_pos = 1;
			if(lat < 0)
			{
				cam_pos = -1;
			}
			move_camera_lat(pano_id,dist,hotspot_angle);	
			return;
		}
		
		lon = (lon + cam_pos*2 + 360)%360;
		angle = angle - cam_pos*2;

		var function_name = function(){move_camera(angle,pano_id,dist,hotspot_angle);}
		clearTimeout(time_out);
		time_out = setTimeout(function_name, 50); 
	}

	function onDocumentMouseDown( event ) {

		event.preventDefault();

		isUserInteracting = true;

		onPointerDownPointerX = event.clientX;
		onPointerDownPointerY = event.clientY;

		onPointerDownLon = lon;
		onPointerDownLat = lat;


		var vector = new THREE.Vector3();
		vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
		vector.unproject( camera );
		raycaster.set( camera.position, vector.sub( camera.position ).normalize() );


		var intersects = raycaster.intersectObjects( scene.children, true );

		if ( intersects.length > 0  && intersects[0].object.name=="current_hotspot") {

			var angle = intersects[0].object.angle - lon;
			if(angle > 180)
			{
				angle = angle - 360;
			}
			if(angle < -180)
			{
				angle = angle + 360;
			}
			if(angle > 0)
			{
				cam_pos = 1;
			}
			else
			{
				cam_pos = -1;
			}
			move_camera(angle,intersects[0].object.pano_id,intersects[0].object.dist,intersects[0].object.angle);
		}

	}

	function onDocumentMouseMove( event ) {

		if ( isUserInteracting === true ) {

			lon = ( onPointerDownPointerX - event.clientX ) * mouse_speed + onPointerDownLon;
			lon = (lon + 360)% 360;
			lat = ( event.clientY - onPointerDownPointerY ) * mouse_speed + onPointerDownLat;

		}

	}

	function onDocumentMouseUp( event ) {

		isUserInteracting = false;

	}

	var maxspeed = 7;
	var current_speed = 2;
	var done = false;
	function onDocumentKeyDown( event ) {

		if (!event)
			event = window.event;
		var code = event.keyCode;

		if (code == 37)
		{
			lon-=current_speed;
			lon = (lon+360) % 360;
		}
		else if ( code ==39 )
		{
			lon += current_speed;
			lon = (lon+360) % 360;
		}
		else if (code == 38)
		{
			if(done == false)
			{
				var total = hotspots_angle[current_pano].length;
				var near_angle,near_id;
				var flag = false;
				var temp;

				for(i=0;i<total;i++)
				{
					temp = hotspots_angle[current_pano][i][1] - 90;
					if(temp < 0 )
					{
						temp = temp + 360;
					}
					if( ((lon>=45) &&(lon<=315) && (temp<=(lon+45)%360) &&(temp>=(lon-45)%360)) || ((lon<=45) && (temp>=0) && (temp<=lon+45)) || ((lon<=45)&&(temp>=(lon-45)%360) && (temp<=360)) ||  ((lon>=315) && (temp>=(lon-45)) && (temp<=360)) || ((lon>=315)&&(temp>=0) &&(temp<= (lon+45)%360)) )
					{

						if(flag == false)
						{
							near_angle = temp;
							near_id = i;

							flag = true;
						}
						if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
						{
							near_angle = temp;
							near_id = i;

							flag = true;

						}
					}
				}
				if(flag == true)
				{
					var angle = near_angle - lon;
					if(angle > 180)
					{
						angle = angle - 360;
					}
					if(angle < -180)
					{
						angle = angle + 360;
					}
					if(angle > 0)
					{
						cam_pos = 1;
					}
					else
					{
						cam_pos = -1;
					}
					move_camera(angle,hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
				}
				done = true;
			}
		}
		if (isUserInteracting == true) {
			if(current_speed < maxspeed)
				current_speed+=1;
		}
		isUserInteracting = true;
	}


	function onDocumentKeyUp ( event ) 
	{

		isUserInteracting = false;
		current_speed = 2;
		done = false;
	}

	function onDocumentMouseWheel( event ) {



		if ( event.wheelDeltaY ) {

			camera.fov -= event.wheelDeltaY * 0.05;



		} else if ( event.wheelDelta ) {

			camera.fov -= event.wheelDelta * 0.05;



		} else if ( event.detail ) {

			camera.fov += event.detail * 1.0;

		}

		camera.updateProjectionMatrix();

	}

	function animate() {

		requestAnimationFrame( animate );
		update();

	}

	function update() {
		lat = Math.max( - 35, Math.min( 35, lat ) );
		phi = THREE.Math.degToRad( 90 - lat );
		theta = THREE.Math.degToRad( lon );

		camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
		camera.target.y = 500 * Math.cos( phi );
		camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );

		camera.lookAt( camera.target );

		renderer.render( scene, camera );

	}

		</script>
	</body>
	</html>
