<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - equirectangular panorama demo</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		background-color: #000000;
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		color: #ffffff;
		padding: 5px;
		font-family:Monospace;
		font-size:13px;
		font-weight: bold;
		text-align:center;
	}

	a {
		color: #ffffff;
	}
	</style>
</head>
<body>

	<div id="container"></div>
	<div id="info">
		<a href="http://threejs.org" target="_blank">three.js webgl</a> - equirectangular panorama demo. photo by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank">JÃ³n Ragnarsson</a>.<br />
		drag equirectangular texture into the page.
	</div>

	<script src="../build/three.min.js"></script>

	<script>
	var camera, scene, renderer;
	var raycaster;
	raycaster = new THREE.Raycaster();
	var current_pano;
	var clear_pano;
	var curr_speed,acc,time;
	var test,remove;
	var cam_pos;

	var isUserInteracting = false,
	onMouseDownMouseX = 0, onMouseDownMouseY = 0,
	lon = 0, onMouseDownLon = 0,
	lat = 0, onMouseDownLat = 0,
	phi = 0, theta = 0;

	var hotspots_angle = [[[1,109,47]], [[2,52,48], [4,111,98], [0,303,43]], [[3,107,58], [1,230,48]], [[2,293,58], [4,185,45]], [[3,5,41], [1,288,93]]]; 

	init('panos/1/resized_1.jpg');
	animate();

	function loadNewmesh(pano_id,old_pano,dist,angle)
	{
		//var geometry = new THREE.SphereGeometry( 500, 60, 40 );
		//geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

		//var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( path )} );

		//mesh = new THREE.Mesh( geometry, material );
		//mesh.name = "current_mesh";
		//mesh.material.transparent = true;
		//mesh.material.opacity = 1;	
		//mesh.material.blending = THREE.AdditiveBlending;
		var par = pano_id + 1;
		var path = "panos/"+par+"/blur_";
		var new_pano = create_mesh(path,1.0);
		//scene.add( mesh );
		curr_speed = 2;
		time = 40;
		dist = 1.5*dist;
		test = false;
		remove = false;

		acc = (2*(curr_speed*time - dist))/(time*time);
		loadclearmesh(pano_id);
		updateOpacity(old_pano,new_pano,dist,angle,pano_id,1);
	}
	function loadclearmesh(pano_id)
	{
		pano_id += 1;
		//var path = "panos/" + pano_id +"/resized_"+pano_id+ ".jpg";
		//var geometry = new THREE.SphereGeometry( 500, 60, 40 );
		//geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

		//var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( path )} );

		//mesh = new THREE.Mesh( geometry, material );
		//mesh.name = "current_mesh";
		//mesh.material.transparent = true;
		//mesh.material.blending = THREE.AdditiveBlending;
		//mesh.material.opacity = 0;
		//scene.add( mesh );
		var path = "panos/"+pano_id+"/1024/mobile_";
		clear_pano = create_mesh(path,0);

		return;

	}
	function updateOpacity(old_pano,new_pano,dist,angle,pano_id,count)
	{ 
		if(remove==false)
		{
			var speed;
			speed = -1*curr_speed*count + 0.5*acc*count*count;

			old_pano.position.x = speed*Math.cos(THREE.Math.degToRad(angle ));
			old_pano.position.z = speed*Math.sin(THREE.Math.degToRad(angle ));

			count = count + 1;
			for(i=0;i<6;i++)
			{
				old_pano.material.materials[i].opacity -= 0.001;
			}
		}
		if(remove==true)
		{
			count = count + 1;
			for(i=0;i<6;i++)
			{
				clear_pano.material.materials[i].opacity += 1/time;
				new_pano.material.materials[i].opacity -= 1/time;
			}
		}
		if(count==time && remove==false)
		{	
			old_pano.geometry.dispose();
			for(i=0;i<6;i++)
			{
				old_pano.material.materials[i].map.dispose();
				old_pano.material.materials[i].dispose();	
			}
			//renderer.deallocateObject(old_pano);
			
			count = 0;
			for(i=0;i<6;i++)
			{
				new_pano.material.materials[i].opacity = 1;
			}
			remove = true;
			scene.remove(old_pano);
		}
		if(count==time && remove==true)
		{
			
			new_pano.geometry.dispose();
			for(i=0;i<6;i++)
			{
				new_pano.material.materials[i].map.dispose();
				new_pano.material.materials[i].dispose();	
			}
			scene.remove(new_pano);
			for(i=0;i<6;i++)
			{
				clear_pano.material.materials[i].opacity = 1;
			}
			Hotspots(pano_id);
			return;
		}

		setTimeout(function(){updateOpacity(old_pano,new_pano,dist,angle,pano_id,count);}, 20); 
	}	
	function removemesh(pano_id,dist,angle) {
		current_pano = pano_id;
		var old_pano = scene.getObjectByName("current_mesh");

		var len = scene.children.length;
		var p=0;
		for ( i = 0; i < len; i ++ ) {
			var object = scene.children[ p];

			if(object.name!=old_pano.name)
			{
				
				object.geometry.dispose();
				object.material.dispose();
				scene.remove(object);
			}
			else
			{
				p = p + 1;
			}
		}
		//var images_loc = pano_id+1;
		//images_loc = "panos/" + images_loc +"/blur_"+images_loc+ ".jpg";
		loadNewmesh(pano_id,old_pano,dist,angle);
		animate();
	}
	function create_mesh(path,opacity)
	{
		//pano_id += 1;
		//path = "panos/"+pano_id+"/";
		var materials = [

					loadTexture(path+"r.jpg"), // right
					loadTexture(path+"l.jpg"), // left
					loadTexture(path+"u.jpg"), // top
					loadTexture(path+"d.jpg"), // bottom
					loadTexture(path+"f.jpg"), // front
					loadTexture(path+"b.jpg")  // back

				];
		var mesh = new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 300, 7, 7, 7 ), new THREE.MeshFaceMaterial( materials ) );
		mesh.scale.x = -1;

		console.log(mesh);

		for(i=0;i<6;i++)
		{
			mesh.material.materials[i].transparent = true;
			mesh.material.materials[i].opacity = opacity;
			mesh.material.materials[i].blending = THREE.AdditiveBlending;
		}
		mesh.name = "current_mesh";
		scene.add(mesh);

		return mesh;

	}

	function init() 
	{
		var container, mesh;

		container = document.getElementById( 'container' );

		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
		camera.target = new THREE.Vector3( 0, 0, 0 );
		//console.log(camera);

		scene = new THREE.Scene();

		texture_placeholder = document.createElement( 'canvas' );
		texture_placeholder.width = 128;
		texture_placeholder.height = 128;

		var context = texture_placeholder.getContext( '2d' );
		context.fillStyle = 'rgb( 200, 200, 200 )';
		context.fillRect( 0, 0, texture_placeholder.width, texture_placeholder.height );

		/*var materials = [

					loadTexture(right_img), // right
					loadTexture(left_img ), // left
					loadTexture(top_img), // top
					loadTexture(bottom_img), // bottom
					loadTexture(front_img), // front
					loadTexture(back_img)  // back

				];
		mesh = new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 300, 7, 7, 7 ), new THREE.MeshFaceMaterial( materials ) );
		//var geometry = new THREE.SphereGeometry( 500, 60, 40 );
		//geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

		//var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( path )} );

		//mesh = new THREE.Mesh( geometry, material );*/
		//mesh.name="current_mesh";
		var path = "panos/1/1024/mobile_";
		create_mesh(path,1.0);
		current_pano = 0;
		//mesh.material.transparent = true;
		//mesh.material.opacity = 1.0;
		//mesh.material.blending = THREE.AdditiveBlending;
		//scene.add( mesh );

		Hotspots(0);

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mouseup', onDocumentMouseUp, false );
		document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
		document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false);

		document.addEventListener( 'keydown', onDocumentKeyDown, false );
		document.addEventListener( 'keyup', onDocumentKeyUp, false );

		document.addEventListener( 'dragover', function ( event ) {

			event.preventDefault();
			event.dataTransfer.dropEffect = 'copy';

		}, false );

		document.addEventListener( 'dragenter', function ( event ) {

			document.body.style.opacity = 0.5;

		}, false );

		document.addEventListener( 'dragleave', function ( event ) {

			document.body.style.opacity = 1;

		}, false );

		document.addEventListener( 'drop', function ( event ) {

			event.preventDefault();

			var reader = new FileReader();
			reader.addEventListener( 'load', function ( event ) {

				material.map.image.src = event.target.result;
				material.map.needsUpdate = true;

			}, false );
			reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

			document.body.style.opacity = 1;

		}, false );


		window.addEventListener( 'resize', onWindowResize, false );

	}
	function loadTexture( path ) {

				var texture = new THREE.Texture( texture_placeholder );
				var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );

				var image = new Image();
				image.onload = function () {

					texture.image = this;
					texture.needsUpdate = true;

				};
				image.src = path;

				return material;

	}
	function Hotspots(pano_id)
	{
		total = hotspots_angle[pano_id].length;
		for(i=0;i<total;i++)
		{
			add_Hotspot(hotspots_angle[pano_id][i][0],hotspots_angle[pano_id][i][1],hotspots_angle[pano_id][i][2]);
		}
	}
	function add_Hotspot(pano_id,angle,dist)
	{
		var geometry = new THREE.BoxGeometry( 2,2,2,1,1,1);
		var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
		var cube = new THREE.Mesh( geometry, material );

		angle = angle - 90;
		rad_angle = THREE.Math.degToRad( angle );
		cube.position.x = dist*Math.cos(rad_angle);
		cube.position.y = -10;
		cube.position.z = dist*Math.sin(rad_angle);
		cube.pano_id = pano_id;
		cube.dist = dist;
		cube.angle = angle;
		cube.name = "current_hotspot";
		scene.add( cube );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}
	function time_change(count)
	{
		if(count==5)
		{
			return;
		}
		setTimeout(function(){time_change(count+1);}, 15); 
	}
	function move_camera_lat (pano_id, dist, hotspot_angle) {
		if(lat > 0)
		{
			lat = lat - 2;
		}
		else
		{
			lat = lat + 2;
		}

		if(Math.abs(lat) <2)
		{
			removemesh(pano_id,dist,hotspot_angle);
			return;
		}
		setTimeout(function(){move_camera_lat(pano_id, dist, hotspot_angle);}, 20); 
	}
	function move_camera(angle,pano_id,dist,hotspot_angle)
	{
		if(cam_pos*angle<=0)
		{
			move_camera_lat(pano_id, dist, hotspot_angle);
			return;
		}
		lon = lon + cam_pos*2;
		angle = angle - cam_pos*2;

		setTimeout(function(){move_camera(angle,pano_id,dist,hotspot_angle);}, 20); 
	}

	function onDocumentMouseDown( event ) {

		event.preventDefault();

		isUserInteracting = true;

		onPointerDownPointerX = event.clientX;
		onPointerDownPointerY = event.clientY;

		onPointerDownLon = lon;
		onPointerDownLat = lat;


		var vector = new THREE.Vector3();
		vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
		vector.unproject( camera );
		raycaster.set( camera.position, vector.sub( camera.position ).normalize() );


		var intersects = raycaster.intersectObjects( scene.children, true );

		if ( intersects.length > 0  && intersects[0].object.name=="current_hotspot") {

			var angle = intersects[0].object.angle - lon;
			if(angle > 180)
			{
				angle = angle - 360;
			}
			if(angle < -180)
			{
				angle = angle + 360;
			}
			if(angle > 0)
			{
				cam_pos = 1;
			}
			else
			{
				cam_pos = -1;
			}
			//move_camera_lat();
			move_camera(angle,intersects[0].object.pano_id,intersects[0].object.dist,intersects[0].object.angle);
		}

	}

	function onDocumentMouseMove( event ) {

		if ( isUserInteracting === true ) {

			lon = ( onPointerDownPointerX - event.clientX ) * 0.3 + onPointerDownLon;
			lat = ( event.clientY - onPointerDownPointerY ) * 0.3 + onPointerDownLat;

		}

	}

	function onDocumentMouseUp( event ) {

		isUserInteracting = false;

	}

	var maxspeed = 7;
	var current_speed = 2;
	var done = false;
	function onDocumentKeyDown( event ) {

		if (!event)
			event = window.event;
		var code = event.keyCode;

		if (code == 37)
			lon-=current_speed;
		else if ( code ==39 )
			lon += current_speed;
		else if (code == 38)
		{
			if(done == false)
			{
				var total = hotspots_angle[current_pano].length;
				var near_angle,near_id;
				var flag = false;
				var temp;

				for(i=0;i<total;i++)
				{
					temp = hotspots_angle[current_pano][i][1] - 90;
					if(temp < 0 )
					{
						temp = temp + 360;
					}
					console.log(temp + " " + lon);
					if( ((lon>=45) &&(lon<=315) && (temp<=(lon+45)%360) &&(temp>=(lon-45)%360)) || ((lon<=45) && (temp>=0) && (temp<=lon+45)) || ((lon<=45)&&(temp>=(lon-45)%360) && (temp<=360)) ||  ((lon>=315) && (temp>=(lon-45)) && (temp<=360)) || ((lon>=315)&&(temp>=0) &&(temp<= (lon+45)%360)) )
					{

						if(flag == false)
						{
							near_angle = temp;
							near_id = i;

							flag = true;
						}
						if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
						{
							near_angle = temp;
							near_id = i;

							flag = true;

						}
					}
				}
				if(flag == true)
				{
					var angle = near_angle - lon;
					if(angle > 180)
					{
						angle = angle - 360;
					}
					if(angle < -180)
					{
						angle = angle + 360;
					}
					if(angle > 0)
					{
						cam_pos = 1;
					}
					else
					{
						cam_pos = -1;
					}
					//move_camera_lat();
					move_camera(angle,hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
				}
				done = true;
			}
		}
			/*else if ( code == 40 )
			{
				if(done == false)
				{
					var total = hotspots_angle[current_pano].length;
					var near_angle,near_id;
					var flag = false;
					var temp;
					lon = lon % 360;
					for(i=0;i<total;i++)
					{
						lon = lon % 360;
						temp = hotspots_angle[current_pano][i][1] - 90;
						if(temp < 0 )
						{
							temp = temp + 360;
						}

						if((temp>=(lon+135)%360) && (temp<=(lon+225)%360))
						{

							if(flag==false)
							{
								near_angle = temp;
								near_id = i;

								flag = true;
							}
							if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
							{
								near_angle = temp;
								near_id = i;

								flag = true;

							}
						}
					}
					if(flag == true)
					{
						removemesh(hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
					}
					done = true;
				}
			}*/
			if (isUserInteracting == true) {
				if(current_speed < maxspeed)
					current_speed+=1;
			}
			isUserInteracting = true;
		}


		function onDocumentKeyUp ( event ) 
		{

			isUserInteracting = false;
			current_speed = 0.4;
			done = false;
		}

		function onDocumentMouseWheel( event ) {



			if ( event.wheelDeltaY ) {

				camera.fov -= event.wheelDeltaY * 0.05;



			} else if ( event.wheelDelta ) {

				camera.fov -= event.wheelDelta * 0.05;



			} else if ( event.detail ) {

				camera.fov += event.detail * 1.0;

			}

			camera.updateProjectionMatrix();

		}

		function animate() {

			requestAnimationFrame( animate );
			update();

		}

		function update() {

			if(lon > 360)
			{
				lon -= 360;
			}
			else if (lon < 0)
			{
				lon += 360;
			}
			lat = Math.max( - 35, Math.min( 85, lat ) );
			phi = THREE.Math.degToRad( 90 - lat );
			theta = THREE.Math.degToRad( lon );

			camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
			camera.target.y = 500 * Math.cos( phi );
			camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );

			camera.lookAt( camera.target );

			renderer.render( scene, camera );

		}

		</script>
	</body>
	</html>
