<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - panorama demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: rgb(200,200,200);
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				font-weight: bold;
				text-align:center;
			}

			a {
				color: #ffffff;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
		
		<button onclick = "removemesh();">Try it</button>
		<a href="http://threejs.org" target="_blank">three.js</a> - panorama demo. cubemap by <a href="http://www.zfight.com/" target="_blank">Jochum Skoglund</a>.</div>

		<script src="../build/three.min.js"></script>

		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			var camera, scene, renderer, raycaster;
			raycaster = new THREE.Raycaster();
			var mouse;
			//var old_pano,new_pano;
			var cam_angle=0;
			var test;
			//var old_pano,new_pano;
			var current_pano; //for up and down arrow key functionality
			mouse = new THREE.Vector2();
			var curr_speed,acc,time;

			var texture_placeholder,
			isUserInteracting = false,
			onMouseDownMouseX = 0, onMouseDownMouseY = 0,
			lon = 90, onMouseDownLon = 0,
			lat = 0, onMouseDownLat = 0,
			phi = 0, theta = 0,

			target = new THREE.Vector3();
			var hotspots_angle = [[[1,109,47]], [[2,52,48], [4,111,98], [5,122,51], [0,303,43]], [[3,107,58], [1,230,48]], [[2,293,58], [4,185,41]], [[3,5,41], [1,288,93], [5,278,45]], [[1,307,51], [4,105,46]]]; 

			init('panos/1.tiles/mobile_r.jpg','panos/1.tiles/mobile_l.jpg','panos/1.tiles/mobile_u.jpg','panos/1.tiles/mobile_d.jpg','panos/1.tiles/mobile_f.jpg','panos/1.tiles/mobile_b.jpg');
			animate();
			
			
			function loadNewmesh(pano_id, right_img, left_img, top_img, bottom_img, front_img, back_img,old_pano,dist,angle)
			{
				var materials = [

					loadTexture(right_img), // right
					loadTexture(left_img), // left
					loadTexture(top_img), // top
					loadTexture(bottom_img), // bottom
					loadTexture(front_img), // front
					loadTexture(back_img)  // back

				];
				mesh = new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 300, 7, 7, 7 ), new THREE.MeshFaceMaterial( materials ) );
				mesh.scale.x = - 1;
				mesh.name = "current_mesh";

				//console.log(camera);
				/*for(i=0;i<6;i++)
				{
					mesh.material.materials[i].opacity = 0;				
				}*/
				var new_pano = mesh;
				//scene.add( mesh );
				curr_speed = 5;
				time = 10;
				dist = 2*dist;
				
				acc = (2*(curr_speed*time - dist))/(time*time);
				//console.log(old_pano);
				updateOpacity(old_pano,new_pano,dist,angle,pano_id,1);
				
				
			}
			function updateOpacity(old_pano,new_pano,dist,angle,pano_id,count) { 
				//old_pano.scale.z = 2;
				//old_pano.scale.x -= 0.3;
				//old_pano.scale.z = 0.3;
				//console.log;
				//angle = THREE.Math.degToRad( angle );
				var speed = -1*curr_speed*count + 0.5*acc*count*count;
				//console.log(speed);
				old_pano.position.x = speed*Math.cos(THREE.Math.degToRad(angle ));
				old_pano.position.z = speed*Math.sin(THREE.Math.degToRad(angle ));

				/*for(i=0;i<6;i++)
				{
					//old_pano.material.materials[i].opacity -= 0.1;	
					//old_pano.material.materials[i].scale.z = 0.5;
					
					//console.log(old_pano.scale.x);		
				}*/
  					//console.log(old_pano.material.material[0].opacity);
  					if(count==time ) {
   							scene.remove(old_pano);
   							scene.add(new_pano);
   							Hotspots(pano_id);
   						//console.log('*');
   							return;
 					}
 					else {
	
   					setTimeout(function(){updateOpacity(old_pano,new_pano,dist,angle,pano_id,count+1);}, 50); // 50 is the delay, 50milliseconds
 					}
						}	
			function removemesh(pano_id,dist,angle) {
					current_pano = pano_id;
    				var old_pano = scene.getObjectByName("current_mesh");
    				//scene.remove( selectedObject );
    				//selectedObject = scene.getObjectByName("current_hotspot");
    				//scene.remove( selectedObject );
    				var len = scene.children.length;
    				var p=0;
    				for ( i = 0; i < len; i ++ ) {
    							var object = scene.children[ p];
    							//console.log(old_pano.name);
    							//console.log(object.name);
    							if(object.name!=old_pano.name)
    							{
        							scene.remove(object);
        						}
        						else
        						{
        						//	object.material.opacity = 0;
        							p = p + 1;
        						}
					}
    				var images_loc = pano_id+1;
    				images_loc = "panos/" + images_loc + ".tiles";
				loadNewmesh(pano_id, images_loc + '/mobile_r.jpg',images_loc + '/mobile_l.jpg',images_loc + '/mobile_u.jpg',images_loc + '/mobile_d.jpg',images_loc + '/mobile_f.jpg',images_loc + '/mobile_b.jpg',old_pano,dist,angle);
    				animate();
			}


			function init(right_img, left_img, top_img, bottom_img, front_img, back_img) {

				var container, mesh;

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
				camera.fov = 60;
				//camera = new THREE.OrthographicCamera(window.innerWidth/ -2, window.innerWidth/ 2, window.innerHeight/2, window.innerHeight/ -2, 0, 1000 );
				scene = new THREE.Scene();

				texture_placeholder = document.createElement( 'canvas' );
				texture_placeholder.width = 128;
				texture_placeholder.height = 128;

				var context = texture_placeholder.getContext( '2d' );
				context.fillStyle = 'rgb( 200, 200, 200 )';
				context.fillRect( 0, 0, texture_placeholder.width, texture_placeholder.height );

				var materials = [

					loadTexture(right_img), // right
					loadTexture(left_img ), // left
					loadTexture(top_img), // top
					loadTexture(bottom_img), // bottom
					loadTexture(front_img), // front
					loadTexture(back_img)  // back

				];

				/*var geometry = new THREE.SphereGeometry( 500, 60, 40 );
				geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

				var material = new THREE.MeshBasicMaterial( {
					map: THREE.ImageUtils.loadTexture( 'textures/HousingPilot2/1/1.jpg' )
				} );

				mesh = new THREE.Mesh( geometry, material );
		*/		
				
			
				mesh = new THREE.Mesh( new THREE.BoxGeometry( 300, 300, 300, 7, 7, 7 ), new THREE.MeshFaceMaterial( materials ) );
				mesh.scale.x = - 1;
				mesh.name = "current_mesh";
				current_pano = 0;
				//mesh.THREE.ImageUtils.crossOrigin = "anonymous";
				//mesh.callback = function() { console.log( "FUNCTION" ); }
					//console.log(mesh);
				scene.add( mesh );
				test = mesh;
				Hotspots(0);

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

				//document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				//document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );

				window.addEventListener( 'resize', onWindowResize, false );

			}
                        function Hotspots(pano_id)
                        {
                        		total = hotspots_angle[pano_id].length;
                                for(i=0;i<total;i++)
                                {
                                        add_Hotspot(hotspots_angle[pano_id][i][0],hotspots_angle[pano_id][i][1],hotspots_angle[pano_id][i][2]);
                                }
                        }
                        function add_Hotspot(pano_id,angle,dist)
                        {
                                var geometry = new THREE.BoxGeometry( 2,2,2,1,1,1);
                                var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
                                var cube = new THREE.Mesh( geometry, material );
                                
                                //angle = 180-angle;
                               /* if(angle>0)
                                {
                                	angle -= 30;
                                }
                                else
                                {
                                	angle += 30;
                                }*/
                               // dist = dist - 7;
                               angle = angle - 90; 
                                rad_angle = THREE.Math.degToRad( angle );
                                cube.position.x = dist*Math.cos(rad_angle);
                                cube.position.y = -10;
                                cube.position.z = dist*Math.sin(rad_angle);
								cube.pano_id = pano_id;
								cube.dist = dist;
								cube.angle = angle;
								cube.name = "current_hotspot";
                                scene.add( cube );

                        }

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function loadTexture( path ) {

				var texture = new THREE.Texture( texture_placeholder );
				var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );

				var image = new Image();
				image.onload = function () {

					texture.image = this;
					texture.needsUpdate = true;

				};
				image.src = path;

				return material;

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				isUserInteracting = true;

				onPointerDownPointerX = event.clientX;
				onPointerDownPointerY = event.clientY;

				onPointerDownLon = lon;
				onPointerDownLat = lat;
				mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
                                mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

				var vector = new THREE.Vector3();
                		vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 ); // z = 0.5 important!
    				vector.unproject( camera );
    				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
				
				
				var intersects = raycaster.intersectObjects( scene.children, true );
				
				if ( intersects.length > 0 ) {
				  // console.log(intersects[0].object.dist);
				//  console.log(intersects[0].object.angle);
     				   removemesh(intersects[0].object.pano_id,intersects[0].object.dist,intersects[0].object.angle);
     				   scene.remove(intersects[0].object);

    				}

			}

			function onDocumentMouseMove( event ) {

				if ( isUserInteracting === true ) {

					lon = ( onPointerDownPointerX - event.clientX ) * 0.3 + onPointerDownLon;
					lat = ( event.clientY - onPointerDownPointerY ) * 0.3 + onPointerDownLat;

				}

			}

			function onDocumentMouseUp( event ) {

				isUserInteracting = false;

			}

			function onDocumentMouseWheel( event ) {

				camera.fov -= event.wheelDeltaY * 0.001;
				camera.updateProjectionMatrix();

			}


			var maxspeed = 5;
			var current_speed = 0.4;
			var done = false;
			function onDocumentKeyDown( event ) {

				if (!event)
          			event = window.event;
     			var code = event.keyCode;
     			//console.log(event);
     			
     			if (code == 37)
     				lon-=current_speed;
     			else if ( code ==39 )
     				lon += current_speed;
     			else if (code == 38)
     			{
     				if(done == false)
     				{
     					var total = hotspots_angle[current_pano].length;
     					 var near_angle,near_id;
     					 var flag = false;
     					 var temp;
     					 
     					 for(i=0;i<total;i++)
                         {
                         	temp = hotspots_angle[current_pano][i][1] - 90;
                         	if(temp < 0 )
                         	{
                         		temp = temp + 360;
                         	}
                         	console.log(temp + " " + lon);
                            if( ((lon>=45) &&(lon<=315) && (temp<=(lon+45)%360) &&(temp>=(lon-45)%360)) || ((lon<=45) && (temp>=0) && (temp<=lon+45)) || ((lon<=45)&&(temp>=(lon-45)%360) && (temp<=360)) ||  ((lon>=315) && (temp>=(lon-45)) && (temp<=360)) || ((lon>=315)&&(temp>=0) &&(temp<= (lon+45)%360)) )
                            {

                            	if(flag == false)
                            	{
                            			near_angle = temp;
                            			near_id = i;
                            			
                            			flag = true;
                            	}
                            	if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
                            		{
                            			near_angle = temp;
                            			near_id = i;
                            			
                            			flag = true;

                            		}
                            }
                         }
                         if(flag == true)
                         {
                        	removemesh(hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
     					}
     					done = true;
     				}
     				//up;
     			}
     			else if ( code == 40 )
     			{
     				if(done == false)
     				{
     					var total = hotspots_angle[current_pano].length;
     					 var near_angle,near_id;
     					 var flag = false;
     					 var temp;
     					 lon = lon % 360;
     					 for(i=0;i<total;i++)
                         {
                         	lon = lon % 360;
                         	temp = hotspots_angle[current_pano][i][1] - 90;
                         	if(temp < 0 )
                         	{
                         		temp = temp + 360;
                         	}
                         	
                            if((temp>=(lon+135)%360) && (temp<=(lon+225)%360))
                            {

                            	if(flag==false)
                            	{
                            			near_angle = temp;
                            			near_id = i;
                            			
                            			flag = true;
                            	}
                            	if(Math.abs( temp-lon) < Math.abs(near_angle-lon))
                            		{
                            			near_angle = temp;
                            			near_id = i;
                            			
                            			flag = true;

                            		}
                            }
                         }
                         if(flag == true)
                         {
                        	removemesh(hotspots_angle[current_pano][near_id][0], hotspots_angle[current_pano][near_id][2], near_angle);
     					}
     					done = true;
     				}
     				//down
     			}
     			if (isUserInteracting == true) {
     				if(current_speed < maxspeed)
     					current_speed+=0.1;
     			}
     			isUserInteracting = true;
     			//alert(isUserInteracting);
				//lat =  onPointerDownLat;
				/*
     			if (code == 37)
     				lon-=0.1;
     			else if ( code ==39 )
     				lon += 0.1;
     			*///lat = Math.max( - 85, Math.min( 85, lat ) );
     			//update();
     			
			}


			function onDocumentKeyUp ( event ) {

				//alert("UP");
				isUserInteracting = false;
				current_speed = 0.4;
				done = false;
			}




			/*function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					onPointerDownPointerX = event.touches[ 0 ].pageX;
					onPointerDownPointerY = event.touches[ 0 ].pageY;

					onPointerDownLon = lon;
					onPointerDownLat = lat;

				}

			}*/

			/*function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					lon = ( onPointerDownPointerX - event.touches[0].pageX ) * 0.1 + onPointerDownLon;
					lat = ( event.touches[0].pageY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

				}

			}*/



			function animate() {

				requestAnimationFrame( animate );
				update();

			}

			function update() {

				//if ( isUserInteracting === false ) {

					//lon += 0.1;

			//	}
			if(lon > 360)
			{
			lon -= 360;
			}
		else if (lon < 0)
		{
				lon += 360;
}
				lat = Math.max( - 85, Math.min( 85, lat ) );
				phi = THREE.Math.degToRad( 90 - lat );
				theta = THREE.Math.degToRad( lon );

				target.x = 500 * Math.sin( phi ) * Math.cos( theta );
				target.y = 500 * Math.cos( phi );
				target.z = 500 * Math.sin( phi ) * Math.sin( theta );

				//test.position.x -= Math.cos(theta);
				//test.position.z -= Math.sin(theta);

				camera.lookAt( target );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
