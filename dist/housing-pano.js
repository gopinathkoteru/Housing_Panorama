/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var root;

	  root = __webpack_require__(1);

	  root.Hotspot.init(DirectPano.hotspots_angle);

	  root.Transition.init(DirectPano.pano_path);

	  root.Hotspot.add_hotspots(0);

	}).call(this);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var keyMax, keySpeed, onPointerDownLat, onPointerDownLon, onPointerDownPointerX, onPointerDownPointerY, on_key_down, on_key_up, on_mouse_down, on_mouse_move, on_mouse_up, on_mouse_wheel, root, touch_handler;

	  root = __webpack_require__(2);

	  onPointerDownPointerX = void 0;

	  onPointerDownPointerY = void 0;

	  onPointerDownLon = void 0;

	  onPointerDownLat = void 0;

	  keyMax = 7;

	  keySpeed = 2;

	  touch_handler = function(event) {
	    var first, simulatedEvent, touches, type;
	    touches = event.changedTouches;
	    first = touches[0];
	    type = '';
	    switch (event.type) {
	      case 'touchstart':
	        type = 'mousedown';
	        break;
	      case 'touchmove':
	        type = 'mousemove';
	        break;
	      case 'touchend':
	        type = 'mouseup';
	        break;
	      default:
	        return;
	    }
	    simulatedEvent = document.createEvent('MouseEvent');
	    simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0, null);
	    first.target.dispatchEvent(simulatedEvent);
	    event.preventDefault();
	  };

	  on_mouse_down = function(event) {
	    var container, intersects, vector;
	    event.preventDefault();
	    root.Config.isUserInteracting = true;
	    onPointerDownPointerX = event.clientX;
	    onPointerDownPointerY = event.clientY;
	    onPointerDownLon = root.Config.lon;
	    onPointerDownLat = root.Config.lat;
	    vector = new THREE.Vector3;
	    container = document.getElementById('container');
	    vector.set(event.clientX / container.offsetWidth * 2 - 1, -(event.clientY / container.offsetHeight) * 2 + 1, 0.5);
	    vector.unproject(root.camera);
	    root.raycaster.set(root.camera.position, vector.sub(root.camera.position).normalize());
	    intersects = root.raycaster.intersectObjects(root.scene.children, true);
	    if (intersects.length > 0 && intersects[0].object.name === 'hotspot') {
	      root.Transition.start(intersects[0].object.hotspot_id);
	    }
	  };

	  on_mouse_move = function(event) {
	    var mouseSpeed;
	    if (root.Config.isUserInteracting === true) {
	      mouseSpeed = 0.3;
	      root.Config.lon = (onPointerDownPointerX - event.clientX) * mouseSpeed + onPointerDownLon;
	      root.Config.lat = (event.clientY - onPointerDownPointerY) * mouseSpeed + onPointerDownLat;
	    }
	  };

	  on_mouse_up = function(event) {
	    root.Config.isUserInteracting = false;
	    root.Config.stop_time = Date.now();
	    root.Config.autoplay = false;
	  };

	  on_mouse_wheel = function(event) {
	    if (event.wheelDeltaY) {
	      root.camera.fov -= event.wheelDeltaY * 0.05;
	    } else if (event.wheelDelta) {
	      root.camera.fov -= event.wheelDelta * 0.05;
	    } else if (event.detail) {
	      root.camera.fov += event.detail * 1.0;
	    }
	    root.camera.fov = Math.max(60, Math.min(90, root.camera.fov));
	    root.camera.updateProjectionMatrix();
	  };

	  on_key_down = function(event) {
	    var keyPressed, near_id;
	    near_id = void 0;
	    if (!event) {
	      event = window.event;
	    }
	    root.Config.isUserInteracting = true;
	    keyPressed = event.keyCode;
	    if (keyPressed === 37) {
	      root.Config.lon -= keySpeed;
	    } else if (keyPressed === 39) {
	      root.Config.lon += keySpeed;
	    } else if (keyPressed === 38) {
	      if (root.Transition.moving === false) {
	        near_id = root.Hotspot.front_nearest_hotspot(root.Transition.current_pano);
	        if (near_id !== -1) {
	          root.Transition.start(near_id);
	        }
	      }
	    } else if (keyPressed === 40) {
	      if (root.Transition.moving === false) {
	        near_id = root.Hotspot.back_nearest_hotspot(root.Transition.current_pano);
	        if (near_id !== -1) {
	          root.Transition.start(near_id);
	        }
	      }
	    }
	    if (root.Config.isUserInteracting === true) {
	      if (keySpeed < keyMax) {
	        keySpeed += 1;
	      }
	    }
	  };

	  on_key_up = function(event) {
	    root.Config.isUserInteracting = false;
	    keySpeed = 2;
	    root.Config.stop_time = Date.now();
	    root.Config.autoplay = false;
	  };

	  $("#" + DirectPano.pano_div_id).on({
	    click: function(event) {
	      document.getElementById(DirectPano.pano_div_id).focus();
	    },
	    mousedown: function(event) {
	      on_mouse_down(event);
	    },
	    mousemove: function(event) {
	      on_mouse_move(event);
	    },
	    mouseup: function(event) {
	      on_mouse_up(event);
	    },
	    mousewheel: function(event) {
	      on_mouse_wheel(event.originalEvent);
	    },
	    DOMMouseScroll: function(event) {
	      on_mouse_wheel(event.originalEvent);
	    },
	    touchstart: function(event) {
	      touch_handler(event);
	    },
	    touchmove: function(event) {
	      touch_handler(event);
	    },
	    touchend: function(event) {
	      touch_handler(event);
	    },
	    keydown: function(event) {
	      on_key_down(event);
	    },
	    keyup: function(event) {
	      on_key_up(event);
	    }
	  });

	  module.exports = root;

	}).call(this);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var Transition, root;

	  root = __webpack_require__(3);

	  Transition = {
	    pano: "",
	    current_pano: 0,
	    pano_num: 0,
	    moving: false
	  };

	  Transition.init = function(path) {
	    var clear_pano1, clear_pano2;
	    Transition.path = path;
	    root.clear_images[Transition.current_pano] = [];
	    path = path + (Transition.current_pano + 1) + "/mobile_";
	    Transition.blur_pano = new root.Pano(0, true);
	    clear_pano1 = new root.Pano(0, false);
	    clear_pano2 = new root.Pano(0, false);
	    Transition.blur_pano.create_pano(path, 0.0);
	    clear_pano1.create_pano(path, 1.0);
	    clear_pano2.create_pano(path, 0.0);
	    Transition.clear_pano = [clear_pano1, clear_pano2];
	    Transition.preload_images();
	  };

	  Transition.save_clear_images = function() {
	    var i, path;
	    if (!root.clear_images[Transition.current_pano]) {
	      path = Transition.path + (Transition.current_pano + 1) + "/mobile_";
	      root.clear_images[Transition.current_pano] = [];
	      i = 0;
	      while (i < 6) {
	        (function() {
	          var image, image_index, texture;
	          texture = new THREE.Texture(root.texture_placeholder);
	          image_index = i;
	          image = new Image();
	          image.onload = function() {
	            texture.image = this;
	            texture.needsUpdate = true;
	            if (!root.clear_images[Transition.current_pano][image_index]) {
	              root.clear_images[Transition.current_pano][image_index] = image;
	            }
	          };
	          image.src = path + root.Config.img_name[i] + ".jpg";
	        })();
	        i++;
	      }
	    }
	  };

	  Transition.preload_images = function() {
	    var i;
	    i = 0;
	    while (i < root.Hotspot.hotspot_angles[Transition.current_pano].length) {
	      (function() {
	        var j, pano_id, path;
	        pano_id = root.Hotspot.hotspot_angles[Transition.current_pano][i][0];
	        if (!root.blur_images[pano_id]) {
	          root.blur_images[pano_id] = [];
	          path = Transition.path + "blur_" + (pano_id + 1) + "/mobile_";
	          j = 0;
	          while (j < 6) {
	            (function() {
	              var image, image_index, texture;
	              texture = new THREE.Texture(root.texture_placeholder);
	              image_index = j;
	              image = new Image();
	              image.onload = function() {
	                texture.image = this;
	                texture.needsUpdate = true;
	                if (!root.blur_images[pano_id][image_index]) {
	                  root.blur_images[pano_id][image_index] = image;
	                }
	              };
	              image.src = path + root.Config.img_name[j] + ".jpg";
	            })();
	            j++;
	          }
	        }
	      })();
	      i++;
	    }
	  };

	  Transition.complete = function(pano_id) {
	    Transition.moving = false;
	    root.Hotspot.add_hotspots(pano_id);
	  };

	  Transition.start = function(hotspot_id) {
	    var blur_pano_to_new_pano, check_new_pano_load, dist, find_rotation_angle, hotspot_angle, load_blur_pano, load_clear_pano, old_pano_to_blur_pano, pano_id, rotate_angle;
	    pano_id = root.Hotspot.hotspot_angles[Transition.current_pano][hotspot_id][0];
	    hotspot_angle = root.Hotspot.hotspot_angles[Transition.current_pano][hotspot_id][1];
	    dist = root.Hotspot.hotspot_angles[Transition.current_pano][hotspot_id][2];
	    find_rotation_angle = function() {
	      var rotate_angle;
	      rotate_angle = hotspot_angle - root.Config.lon;
	      while (rotate_angle > 180) {
	        rotate_angle = rotate_angle - 360;
	      }
	      while (rotate_angle < -180) {
	        rotate_angle = rotate_angle + 360;
	      }
	      if (rotate_angle > 50) {
	        rotate_angle = (rotate_angle - 180) % 360;
	      } else if (rotate_angle < -50) {
	        rotate_angle = (rotate_angle + 180) % 360;
	      }
	      rotate_angle = rotate_angle + root.Config.lon;
	      return rotate_angle;
	    };
	    load_blur_pano = function() {
	      var dfrd, i, path;
	      path = Transition.path + "blur_" + (pano_id + 1) + "/mobile_";
	      dfrd = [];
	      i = 0;
	      while (i < 6) {
	        dfrd[i] = $.Deferred();
	        i++;
	      }
	      Transition.blur_pano.pano_id = pano_id;
	      i = 0;
	      while (i < 6) {
	        Transition.blur_pano.mesh.material.materials[i].map.dispose();
	        Transition.blur_pano.mesh.material.materials[i].map = Transition.blur_pano.get_texture(Transition.current_pano, path + root.Config.img_name[i] + ".jpg", dfrd[i], i);
	        Transition.blur_pano.mesh.material.materials[i].opacity = 0;
	        i++;
	      }
	      Transition.blur_pano.mesh.position.x = dist * Math.cos(THREE.Math.degToRad(hotspot_angle));
	      Transition.blur_pano.mesh.position.z = dist * Math.sin(THREE.Math.degToRad(hotspot_angle));
	      return $.when(dfrd[0], dfrd[1], dfrd[2], dfrd[3], dfrd[4], dfrd[5]).done(function() {}).promise();
	    };
	    load_clear_pano = function() {
	      var dfrd, i, path;
	      path = Transition.path + (pano_id + 1) + "/mobile_";
	      dfrd = [];
	      i = 0;
	      while (i < 6) {
	        dfrd[i] = $.Deferred();
	        i++;
	      }
	      Transition.clear_pano[Transition.pano_num].pano_id = pano_id;
	      i = 0;
	      while (i < 6) {
	        Transition.clear_pano[Transition.pano_num].mesh.material.materials[i].map.dispose();
	        Transition.clear_pano[Transition.pano_num].mesh.material.materials[i].map = Transition.clear_pano[Transition.pano_num].get_texture(Transition.current_pano, path + root.Config.img_name[i] + ".jpg", dfrd[i], i);
	        Transition.clear_pano[Transition.pano_num].mesh.material.materials[i].opacity = 0;
	        i++;
	      }
	      return $.when(dfrd[0], dfrd[1], dfrd[2], dfrd[3], dfrd[4], dfrd[5]).done(function() {}).promise();
	    };
	    old_pano_to_blur_pano = function() {
	      var del, i, time, time1;
	      time1 = 0.4;
	      TweenLite.to(root.Config, time1, {
	        lon: rotate_angle,
	        lat: 0,
	        ease: Power0.easeOut
	      });
	      time = 2;
	      del = 0.3;
	      TweenLite.to(Transition.blur_pano.mesh.position, time, {
	        x: 0,
	        z: 0,
	        delay: del,
	        ease: Expo.easeOut
	      });
	      i = 0;
	      while (i < 6) {
	        TweenLite.to(Transition.clear_pano[Transition.pano_num].mesh.material.materials[i], time, {
	          opacity: 0,
	          delay: del,
	          ease: Expo.easeOut
	        });
	        TweenLite.to(Transition.blur_pano.mesh.material.materials[i], time, {
	          opacity: 1,
	          delay: del,
	          ease: Expo.easeOut
	        });
	        i++;
	      }
	      TweenLite.to(Transition.clear_pano[Transition.pano_num].mesh.position, time, {
	        x: -1 * dist * Math.cos(THREE.Math.degToRad(hotspot_angle)),
	        z: -1 * dist * Math.sin(THREE.Math.degToRad(hotspot_angle)),
	        delay: del,
	        ease: Expo.easeOut,
	        onComplete: check_new_pano_load
	      });
	    };
	    check_new_pano_load = function() {
	      var i;
	      Transition.clear_pano[Transition.pano_num].mesh.position.x = 0;
	      Transition.clear_pano[Transition.pano_num].mesh.position.z = 0;
	      i = 0;
	      while (i < 6) {
	        Transition.clear_pano[Transition.pano_num].mesh.material.materials[i].opacity = 0;
	        Transition.clear_pano[Transition.pano_num].mesh.material.materials[i].map.dispose();
	        Transition.blur_pano.mesh.material.materials[i].opacity = 1;
	        i++;
	      }
	      Transition.pano_num = (Transition.pano_num + 1) % 2;
	      load_clear_pano().done(function() {
	        blur_pano_to_new_pano();
	        Transition.preload_images();
	      });
	    };
	    blur_pano_to_new_pano = function() {
	      var i, time;
	      time = 0.5;
	      i = 0;
	      while (i < 6) {
	        TweenLite.to(Transition.blur_pano.mesh.material.materials[i], time, {
	          opacity: 0,
	          ease: Power0.easeOut
	        });
	        i++;
	      }
	      i = 0;
	      while (i < 6) {
	        if (i === 5) {
	          TweenLite.to(Transition.clear_pano[Transition.pano_num].mesh.material.materials[i], time, {
	            opacity: 1,
	            ease: Power0.easeOut,
	            onComplete: Transition.complete,
	            onCompleteParams: [pano_id]
	          });
	        } else {
	          TweenLite.to(Transition.clear_pano[Transition.pano_num].mesh.material.materials[i], time, {
	            opacity: 1,
	            ease: Power0.easeOut
	          });
	        }
	        i++;
	      }
	    };
	    Transition.moving = true;
	    Transition.current_pano = pano_id;
	    Transition.save_clear_images();
	    rotate_angle = find_rotation_angle();
	    root.Hotspot.remove_hotspots();
	    load_blur_pano().done(function() {
	      old_pano_to_blur_pano();
	    });
	  };

	  root.Transition = Transition;

	  module.exports = root;

	}).call(this);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var Hotspot, root;

	  root = __webpack_require__(4);

	  Hotspot = {
	    panoid: void 0,
	    hotspot_angles: void 0
	  };

	  Hotspot.init = function(hotspot_angles) {
	    return Hotspot.hotspot_angles = hotspot_angles;
	  };

	  Hotspot.load_texture = function() {
	    var image, material, texture;
	    texture = new THREE.Texture(window.texture_placeholder);
	    material = new THREE.MeshBasicMaterial({
	      map: texture,
	      overdraw: 0,
	      side: THREE.DoubleSide,
	      blending: THREE.AdditiveBlending,
	      depthTest: false
	    });
	    image = new Image();
	    image.onload = function() {
	      texture.image = this;
	      return texture.needsUpdate = true;
	    };
	    image.src = '../test/images/logo.png';
	    return material;
	  };

	  Hotspot.add_hotspot = function(angle, dist, hotspotId) {
	    var geometry, hotspot, material, rad_angle, v;
	    geometry = new THREE.PlaneBufferGeometry(10, 10, 10);
	    material = Hotspot.load_texture();
	    hotspot = new THREE.Mesh(geometry, material);
	    rad_angle = THREE.Math.degToRad(angle);
	    hotspot.position.x = 60 * Math.cos(rad_angle);
	    hotspot.position.y = -10;
	    hotspot.position.z = 60 * Math.sin(rad_angle);
	    v = new THREE.Vector3(-hotspot.position.x, 400, -hotspot.position.z);
	    hotspot.lookAt(v);
	    hotspot.hotspot_id = hotspotId;
	    hotspot.name = "hotspot";
	    root.scene.add(hotspot);
	  };

	  Hotspot.add_hotspots = function(panoid) {
	    var i, num_hotspots;
	    Hotspot.panoid = panoid;
	    num_hotspots = Hotspot.hotspot_angles[panoid].length;
	    i = 0;
	    while (i < num_hotspots) {
	      Hotspot.add_hotspot(Hotspot.hotspot_angles[panoid][i][1], Hotspot.hotspot_angles[panoid][i][2], i);
	      i++;
	    }
	  };

	  Hotspot.remove_hotspots = function() {
	    var i, len, object, p;
	    len = root.scene.children.length;
	    p = 0;
	    i = 0;
	    while (i < len) {
	      object = root.scene.children[p];
	      if (object.name === "hotspot") {
	        object.geometry.dispose();
	        object.material.dispose();
	        root.scene.remove(object);
	      } else {
	        p += 1;
	      }
	      i++;
	    }
	  };

	  Hotspot.front_nearest_hotspot = function(panoid) {
	    var flag, i, lon, near_angle, near_id, num_hotspots, temp;
	    num_hotspots = Hotspot.hotspot_angles[panoid].length;
	    near_id = -1;
	    near_angle = void 0;
	    flag = false;
	    i = 0;
	    while (i < num_hotspots) {
	      temp = Hotspot.hotspot_angles[panoid][i][1];
	      lon = (root.Config.lon + 360) % 360;
	      if (temp < 0) {
	        temp += 360;
	      }
	      if (((lon >= 45) && (lon <= 315) && (temp <= (lon + 45) % 360) && (temp >= (lon - 45 + 360) % 360)) || ((lon <= 45) && (temp >= 0) && (temp <= lon + 45)) || ((lon <= 45) && (temp >= (lon - 45 + 360) % 360) && (temp <= 360)) || ((lon >= 315) && (temp >= (lon - 45)) && (temp <= 360)) || ((lon >= 315) && (temp >= 0) && (temp <= (lon + 45) % 360))) {
	        if (flag === false || ((Math.abs(temp - lon)) < (Math.abs(near_angle - lon)))) {
	          near_angle = temp;
	          near_id = i;
	          flag = true;
	        }
	      }
	      i++;
	    }
	    return near_id;
	  };

	  Hotspot.back_nearest_hotspot = function(panoid) {
	    var flag, i, lon, near_angle, near_id, num_hotspots, temp;
	    num_hotspots = Hotspot.hotspot_angles[panoid].length;
	    near_id = -1;
	    near_angle = void 0;
	    flag = false;
	    i = 0;
	    while (i < num_hotspots) {
	      temp = Hotspot.hotspot_angles[panoid][i][1];
	      lon = (root.Config.lon + 360 + 180) % 360;
	      if (temp < 0) {
	        temp += 360;
	      }
	      if (((lon >= 45) && (lon <= 315) && (temp <= (lon + 45) % 360) && (temp >= (lon - 45 + 360) % 360)) || ((lon <= 45) && (temp >= 0) && (temp <= lon + 45)) || ((lon <= 45) && (temp >= (lon - 45 + 360) % 360) && (temp <= 360)) || ((lon >= 315) && (temp >= (lon - 45)) && (temp <= 360)) || ((lon >= 315) && (temp >= 0) && (temp <= (lon + 45) % 360))) {
	        if (flag === false || ((Math.abs(temp - lon)) < (Math.abs(near_angle - lon)))) {
	          near_angle = temp;
	          near_id = i;
	          flag = true;
	        }
	      }
	      i++;
	    }
	    return near_id;
	  };

	  root.Hotspot = Hotspot;

	  module.exports = root;

	}).call(this);


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var root;

	  root = __webpack_require__(5);

	  root.Pano = (function() {
	    function Pano(pano_id1, is_blur) {
	      this.pano_id = pano_id1;
	      this.is_blur = is_blur;
	      this.name = "panorama";
	    }

	    Pano.prototype.create_pano = function(path, opacity) {
	      var geometry, i, materials;
	      materials = [];
	      i = 0;
	      while (i < 6) {
	        materials.push(this.load_texture(path + root.Config.img_name[i] + ".jpg", i));
	        i++;
	      }
	      geometry = root.Config.webgl ? new THREE.BoxGeometry(300, 300, 300, 7, 7, 7) : new THREE.BoxGeometry(300, 300, 300, 20, 20, 20);
	      this.mesh = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));
	      this.mesh.scale.x = -1;
	      i = 0;
	      while (i < 6) {
	        this.mesh.material.materials[i].transparent = true;
	        this.mesh.material.materials[i].opacity = opacity;
	        i++;
	      }
	      root.scene.add(this.mesh);
	    };

	    Pano.prototype.load_texture = function(path, image_index) {
	      var image, material, pano_id, texture;
	      texture = new THREE.Texture(root.texture_placeholder);
	      material = new THREE.MeshBasicMaterial({
	        map: texture,
	        overdraw: 0,
	        side: THREE.DoubleSide,
	        blending: THREE.AdditiveBlending,
	        depthTest: false
	      });
	      pano_id = this.pano_id;
	      image = new Image();
	      image.onload = function() {
	        texture.image = this;
	        texture.needsUpdate = true;
	        if (!root.clear_images[pano_id][image_index]) {
	          root.clear_images[pano_id][image_index] = image;
	        }
	      };
	      image.src = path;
	      return material;
	    };

	    Pano.prototype.get_texture = function(panoid, path, dfrd, image_index) {
	      var flag, image, pano_id, texture;
	      flag = false;
	      texture = new THREE.Texture(root.texture_placeholder);
	      pano_id = this.pano_id;
	      if (root.clear_images[panoid][image_index]) {
	        flag = true;
	        texture.image = root.clear_images[panoid][image_index];
	        texture.needsUpdate = true;
	        dfrd.resolve();
	        return texture;
	      }
	      if (this.is_blur === true && root.blur_images[panoid][image_index]) {
	        flag = true;
	        texture.image = root.blur_images[panoid][image_index];
	        texture.needsUpdate = true;
	        dfrd.resolve();
	        return texture;
	      }
	      image = new Image();
	      image.onload = function() {
	        texture.image = this;
	        texture.needsUpdate = true;
	        dfrd.resolve();
	      };
	      image.src = path;
	      return texture;
	    };

	    return Pano;

	  })();

	  module.exports = root;

	}).call(this);


/***/ },
/* 5 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.9.3
	(function() {
	  var Config, animate, blur_images, camera, clear_images, detect_webgl, go_fullscreen, init, raycaster, renderer, root, rotate_camera, scene, texture_placeholder, update;

	  root = {};

	  camera = void 0;

	  scene = void 0;

	  renderer = void 0;

	  texture_placeholder = void 0;

	  raycaster = new THREE.Raycaster;

	  blur_images = {};

	  clear_images = {};

	  Config = {
	    img_name: ['r', 'l', 'u', 'd', 'f', 'b'],
	    isUserInteracting: false,
	    lon: 0,
	    lat: 0,
	    stop_time: void 0,
	    autoplay: true,
	    webgl: true
	  };

	  go_fullscreen = function() {
	    var container, image;
	    container = document.getElementById(DirectPano.pano_div_id);
	    container.style.width = window.innerWidth + 'px';
	    container.style.height = window.innerHeight + 'px';
	    renderer.setSize(window.innerWidth, window.innerHeight);
	    image = document.getElementById('fullscreen-image');
	    image.style.visibility = 'hidden';
	    camera.aspect = window.innerWidth / window.innerHeight;
	    camera.updateProjectionMatrix();
	  };

	  detect_webgl = function() {
	    var canvas, e;
	    try {
	      canvas = document.createElement('canvas');
	      return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
	    } catch (_error) {
	      e = _error;
	      Config.webgl = false;
	      return false;
	    }
	  };

	  init = function() {
	    var container;
	    container = document.getElementById(DirectPano.pano_div_id);
	    scene = new THREE.Scene;
	    texture_placeholder = document.createElement('canvas');
	    texture_placeholder.width = 128;
	    texture_placeholder.height = 128;
	    renderer = detect_webgl() ? new THREE.WebGLRenderer : new THREE.CanvasRenderer;
	    renderer.setPixelRatio(window.devicePixelRatio);
	    console.log(Config.webgl);
	    container.appendChild(renderer.domElement);
	    renderer.setSize(container.offsetWidth, container.offsetHeight);
	    camera = new THREE.PerspectiveCamera(60, container.offsetWidth / container.offsetHeight, 1, 1100);
	    camera.target = new THREE.Vector3(0, 0, 0);
	  };

	  animate = function() {
	    requestAnimationFrame(animate);
	    update();
	  };

	  rotate_camera = function(time, lat) {
	    var duration;
	    if (Config.isUserInteracting === true) {
	      return;
	    }
	    duration = Date.now() - time;
	    if (duration < 1000) {
	      Config.lat = lat - (lat * duration / 1000);
	      requestAnimationFrame(function() {
	        return rotate_camera(time, lat);
	      });
	    } else {
	      Config.lat = 0;
	    }
	  };

	  update = function() {
	    var duration, phi, theta;
	    if (Config.isUserInteracting === false && Config.autoplay === true) {
	      Config.lon += 0.2;
	    } else if (Config.isUserInteracting === false) {
	      duration = Date.now() - Config.stop_time;
	      if (duration > 2000) {
	        Config.autoplay = true;
	        rotate_camera(Date.now(), Config.lat);
	      }
	    }
	    Config.lon = (Config.lon + 360) % 360;
	    Config.lat = Math.max(-35, Math.min(35, Config.lat));
	    phi = THREE.Math.degToRad(90 - Config.lat);
	    theta = THREE.Math.degToRad(Config.lon);
	    camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
	    camera.target.y = 500 * Math.cos(phi);
	    camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);
	    camera.lookAt(camera.target);
	    renderer.render(scene, camera);
	  };

	  init();

	  animate();

	  root.Config = Config;

	  root.camera = camera;

	  root.scene = scene;

	  root.renderer = renderer;

	  root.blur_images = blur_images;

	  root.clear_images = clear_images;

	  root.texture_placeholder = texture_placeholder;

	  root.raycaster = raycaster;

	  document.getElementById(DirectPano.image_div_id).onclick = function() {
	    return go_fullscreen();
	  };

	  module.exports = root;

	}).call(this);


/***/ }
/******/ ]);